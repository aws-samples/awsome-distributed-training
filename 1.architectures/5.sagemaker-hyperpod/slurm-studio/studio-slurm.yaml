AWSTemplateFormatVersion: '2010-09-09'
Description: AWS CloudFormation Template for SageMaker Studio Domain

Parameters:
  ExistingVpcId: 
    Type: AWS::EC2::VPC::Id
    Description: VPC ID from the HyperPod cluster stack
  ExistingSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Subnet IDs from the HyperPod cluster stack
  ExistingFSxLustreId:
    Type: String
    Description: ID of the existing FSx Lustre file system
    AllowedPattern: ^(fs-[0-9a-f]{8,})$
  SharedFSx:
    Type: String
    Description: Whether to use the FSx for Lustre volume shared across all the Studio user profiles or create a private partitions for them
    AllowedValues:
      - "True"
      - "False"
    Default: "True"
  HyperPodClusterName:
    Type: String
    Description: Name of the SageMaker HyperPod Slurm cluster
    Default: "ml-cluster"
  HeadNodeName:
    Type: String
    Description: Name of the SageMaker HyperPod Slurm cluster head node
    Default: "controller-machine"  
  SecurityGroupId:
    Type: AWS::EC2::SecurityGroup::Id
    Description: Security group that allows communication with the HyperPod Slurm controller node (for MUNGE authentication)
  AdditionalUsers:
    Type: CommaDelimitedList
    Description: List of additional users to grant FSx access to (comma-separated)
    Default: ""


Conditions:
  CreatePrivatePartitions: !Equals 
    - !Ref SharedFSx
    - "False"

Resources:
  ## ============================ SageMaker Studio Domain ============================
  SageMakerStudioExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action: sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - sagemaker.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonSageMakerFullAccess
      - arn:aws:iam::aws:policy/AmazonS3FullAccess
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryFullAccess
      - arn:aws:iam::aws:policy/CloudWatchFullAccessV2
      Policies:
        - PolicyName: SlurmAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:CreateStack
                  - cloudformation:DeleteStack
                  - cloudformation:DescribeStacks
                  - cloudformation:ListStacks
                  - iam:AttachRolePolicy
                  - iam:CreateRole
                  - iam:CreateServiceLinkedRole
                  - iam:GetOpenIDConnectProvider
                  - iam:ListOpenIDConnectProviders
                  - iam:TagRole
                Resource: '*'
              - Effect: Allow
                Action:
                  - fsx:DescribeFileSystems
                  - fsx:DescribeFileSystemAliases
                  - fsx:UpdateFileSystem
                  - elasticfilesystem:Describe*
                  - ec2:DescribeAvailabilityZones
                  - q:SendMessage
                  - codewhisperer:GenerateRecommendations
                  - sagemaker-mlflow:*
                Resource: '*'
              - Effect: Allow
                Action:
                  - sagemaker:ListClusterNodes
                  - sagemaker:DescribeClusterNode
                  - sagemaker:DescribeCluster
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:*
                Resource: '*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource: '*'

  SageMakerStudioSlurmCELifecycleConfig:
    Type: AWS::SageMaker::StudioLifecycleConfig
    Properties:
      StudioLifecycleConfigAppType: CodeEditor
      StudioLifecycleConfigContent: 
        Fn::Base64: !Sub |
          #!/bin/bash

          # Create a timestamp for unique log file
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          LOGFILE="/tmp/slurm_lifecycle_$TIMESTAMP.log"

          export HyperPodClusterName=${HyperPodClusterName}
          export HeadNodeName=${HeadNodeName}

          # Create the actual logic file (nohup to get around 5 min limit)
          cat << EOF > /tmp/install_slurm.sh
          #!/bin/bash

          # Create a timestamp for unique log file
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          LOGFILE="/tmp/slurm_lifecycle_\$TIMESTAMP.log"

          # Set up logging
          exec 1> >(tee -a "\$LOGFILE") 2>&1
          set -ex  # Exit on error, print commands as they execute

          export HyperPodClusterName=$HyperPodClusterName
          export HeadNodeName=$HeadNodeName

          # Debug: Print environment variables
          echo "[\$TIMESTAMP] Starting script execution in the background"
          echo "HyperPodClusterName value: \$HyperPodClusterName"
          echo "HeadNodeName value: \$HeadNodeName"
          echo "Current working directory: \$(pwd)"
          echo "Current user: \$(whoami)"

          # Download and execute script
          export TEMP_SCRIPT="/tmp/slurm_setup.sh"
          curl -sL \
              "https://raw.githubusercontent.com/aws-samples/awsome-distributed-training/refs/heads/main/1.architectures/5.sagemaker-hyperpod/slurm-studio/slurm_lifecycle.sh" \
              -o "\$TEMP_SCRIPT"

          chmod +x "\$TEMP_SCRIPT"

          echo "Executing setup script..."
          bash -x "\$TEMP_SCRIPT" "\$HyperPodClusterName" "\$HeadNodeName"

          # Create the completion marker
          touch /tmp/slurm_setup_complete_\$TIMESTAMP
          echo "Lifecycle configuration completed successfully" >> "\$LOGFILE"

          EOF

          # Make the installation script executable
          chmod +x /tmp/install_slurm.sh

          # Start installing in the background
          echo "Starting background installation. Check $LOGFILE for progress..."
          nohup /tmp/install_slurm.sh > /tmp/install_$TIMESTAMP.log 2>&1 &

          # Exit BEFORE timeout (5 min)
          echo "Installation started in the background. Monitor the progress with:"
          echo "tail -f $LOGFILE"
          exit 0
      StudioLifecycleConfigName: !Sub ${AWS::StackName}-ce-slurm-setup

  SageMakerStudioSlurmJLLifecycleConfig:
    Type: AWS::SageMaker::StudioLifecycleConfig
    Properties:
      StudioLifecycleConfigAppType: JupyterLab
      StudioLifecycleConfigContent: 
        Fn::Base64: |
          #!/bin/bash

          # Create a timestamp for unique log file
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          LOGFILE="/tmp/slurm_lifecycle_$TIMESTAMP.log"

          export HyperPodClusterName=${HyperPodClusterName}
          export HeadNodeName=${HeadNodeName}

          # Create the actual logic file (nohup to get around 5 min limit)
          cat << EOF > /tmp/install_slurm.sh
          #!/bin/bash

          # Create a timestamp for unique log file
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          LOGFILE="/tmp/slurm_lifecycle_\$TIMESTAMP.log"

          # Set up logging
          exec 1> >(tee -a "\$LOGFILE") 2>&1
          set -ex  # Exit on error, print commands as they execute

          export HyperPodClusterName=$HyperPodClusterName
          export HeadNodeName=$HeadNodeName

          # Debug: Print environment variables
          echo "[\$TIMESTAMP] Starting script execution in the background"
          echo "HyperPodClusterName value: \$HyperPodClusterName"
          echo "HeadNodeName value: \$HeadNodeName"
          echo "Current working directory: \$(pwd)"
          echo "Current user: \$(whoami)"

          # Download and execute script
          export TEMP_SCRIPT="/tmp/slurm_setup.sh"
          curl -sL \
              "https://raw.githubusercontent.com/aws-samples/awsome-distributed-training/refs/heads/main/1.architectures/5.sagemaker-hyperpod/slurm-studio/slurm_lifecycle.sh" \
              -o "\$TEMP_SCRIPT"

          chmod +x "\$TEMP_SCRIPT"

          echo "Executing setup script..."
          bash -x "\$TEMP_SCRIPT" "\$HyperPodClusterName" "\$HeadNodeName"

          # Create the completion marker
          touch /tmp/slurm_setup_complete_\$TIMESTAMP
          echo "Lifecycle configuration completed successfully" >> "\$LOGFILE"

          EOF

          # Make the installation script executable
          chmod +x /tmp/install_slurm.sh

          # Start installing in the background
          echo "Starting background installation. Check $LOGFILE for progress..."
          nohup /tmp/install_slurm.sh > /tmp/install_$TIMESTAMP.log 2>&1 &

          # Exit BEFORE timeout (5 min)
          echo "Installation started in the background. Monitor the progress with:"
          echo "tail -f $LOGFILE"
          exit 0
      StudioLifecycleConfigName: !Sub ${AWS::StackName}-jl-slurm-setup


  SageMakerStudioDomain:
    Type: AWS::SageMaker::Domain
    Properties:
      DomainName: !Sub ${AWS::StackName}-Domain
      AuthMode: IAM
      VpcId: !Ref ExistingVpcId
      SubnetIds: !Ref ExistingSubnetIds
      AppNetworkAccessType: VpcOnly 
      DefaultUserSettings:
        ExecutionRole: !GetAtt SageMakerStudioExecutionRole.Arn
        CodeEditorAppSettings:
          LifecycleConfigArns:
          - Fn::GetAtt: SageMakerStudioSlurmCELifecycleConfig.StudioLifecycleConfigArn
        JupyterLabAppSettings:
          LifecycleConfigArns:
          - Fn::GetAtt: SageMakerStudioSlurmJLLifecycleConfig.StudioLifecycleConfigArn
        SecurityGroups: 
          - !Ref SecurityGroupId
      DomainSettings:
        SecurityGroupIds:
          - !Ref SecurityGroupId

  ## ============================ Lambda ============================

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonFSxFullAccess
        - arn:aws:iam::aws:policy/AmazonElasticFileSystemFullAccess
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole  
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-lambda-update-security-group
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - fsx:DescribeFileSystems
                  - fsx:UpdateFileSystem
                Resource: '*'
              - Effect: Allow
                Action:
                  - sagemaker:DescribeDomain
                  - sagemaker:UpdateDomain
                  - sagemaker:DescribeUserProfile
                  - sagemaker:UpdateUserProfile
                  - sagemaker:ListClusterNodes
                  - sagemaker:DescribeClusterNode
                  - sagemaker:DescribeCluster
                Resource: '*'
              - Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:DescribeNetworkInterfaces
                  - ec2:CreateNetworkInterfacePermission
                  - ec2:ModifyNetworkInterfaceAttribute
                  - ec2:DescribeSubnets
                  - ec2:AuthorizeSecurityGroupIngress
                  - ec2:RevokeSecurityGroupIngress
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DescribeVpcs
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:*
                Resource: '*'
      RoleName: !Sub ${AWS::StackName}-lambda-security-group-role

  ## ============================ FSx association ============================

  LogsSetupFSxToStudio:
    Type: AWS::Logs::LogGroup
    #DeletionPolicy: Retain
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-setup-fsx-to-studio
      RetentionInDays: 14

  SetupFSxToStudio:
    Type: AWS::Lambda::Function
    DependsOn:
      - LogsSetupFSxToStudio
      - SageMakerStudioDomain
    Properties:
      Description: Lambda function to update FSx Lustre ENIs with SageMaker security group
      FunctionName: !Sub ${AWS::StackName}-setup-fsx-to-studio
      Timeout: 900
      MemorySize: 1024
      EphemeralStorage:
        Size: 2048
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      VpcConfig:
        SecurityGroupIds:
          - !Ref SecurityGroupId
        SubnetIds: !Ref ExistingSubnetIds
      Environment:
        Variables:
          cluster_name: !Ref HyperPodClusterName
          head_node_name: !Ref HeadNodeName
          fsx_file_system_id: !Ref ExistingFSxLustreId
          sagemaker_domain_id: !Ref SageMakerStudioDomain
          shared_fsx: !Ref SharedFSx
          additional_users: !Join [",", !Ref AdditionalUsers]
      Code:
        ZipFile: |
          import os
          import shutil
          import subprocess
          import sys
          import json
          import time
          import logging
          import urllib3
          from typing import List, Dict, Any, Optional, Union, Literal

          # CloudFormation response constants
          http = urllib3.PoolManager()
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def update_requirements(requirements_list: List[str]) -> None:
              """
              Install Python dependencies in a temporary directory.
              
              Args:
                  requirements_list: List of Python package requirements in pip format
              """
              curr_dir = os.getcwd()
              os.chdir('/tmp')

              if os.path.exists("python"):
                  shutil.rmtree("python")
              os.mkdir("python")

              for requirement in requirements_list:
                  logger.info(f"running pip install {requirement}")
                  subprocess.check_call([sys.executable, "-m", "pip", "install", requirement, "-t", "python"])

              os.chdir(curr_dir)

          # Install required packages
          requirements_list = ["boto3==1.37.6", "pyyaml"]
          update_requirements(requirements_list)
          sys.path.insert(0, '/tmp/python/')

          import boto3
          import urllib.request
          import yaml

          ec2_client = boto3.client("ec2")
          sagemaker_client = boto3.client("sagemaker")
          ssm_client = boto3.client('ssm')

          def send(
              event: Dict[str, Any], 
              context: Any, 
              responseStatus: str, 
              responseData: Dict[str, Any], 
              physicalResourceId: Optional[str]=None, 
              noEcho: bool=False
          ) -> None:
              """
              Send a response to CloudFormation custom resource.
              
              Args:
                  event: Lambda event
                  context: Lambda context
                  responseStatus: SUCCESS or FAILED
                  responseData: Response data to send back
                  physicalResourceId: Resource ID (defaults to log stream name)
                  noEcho: Whether to mask the response in CloudFormation console
              """
              responseUrl = event['ResponseURL']

              responseBody = {
                  'Status': responseStatus,
                  'Reason': 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,
                  'PhysicalResourceId': physicalResourceId or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': noEcho,
                  'Data': responseData
              }

              json_responseBody = json.dumps(responseBody)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_responseBody))
              }

              try:
                  response = http.request('PUT', responseUrl, body=json_responseBody.encode('utf-8'), headers=headers)
                  logger.info(f"Status code: {response.status}")
              except Exception as e:
                  logger.error(f"send(..) failed executing http.request(..): {str(e)}")

          def get_sagemaker_security_group_id(sagemaker_domain_id: str) -> str:
              """
              Find the security group ID associated with a SageMaker domain.
              
              Args:
                  sagemaker_domain_id: The ID of the SageMaker domain
                  
              Returns:
                  The ID of the security group associated with the domain
                  
              Raises:
                  ValueError: If no matching security group is found
              """
              logger.info(f"Starting get_sagemaker_security_group_id with domain_id: {sagemaker_domain_id}")
              
              search_name = f"security-group-for-inbound-nfs-{sagemaker_domain_id}"
              logger.info(f"Looking for security group with exact name: {search_name}")
              
              try:
                  # Get all security groups and log their names
                  logger.info("About to call describe_security_groups")
                  try:
                      all_sgs = ec2_client.describe_security_groups()["SecurityGroups"]
                      logger.info("Successfully called describe_security_groups")
                  except Exception as e:
                      logger.error(f"Error calling describe_security_groups: {str(e)}")
                      raise
                      
                  logger.info(f"Processing {len(all_sgs)} security groups")     

                  try:   
                      security_groups = ec2_client.describe_security_groups(
                          Filters=[
                              {
                                  "Name": "group-name",
                                  "Values": [search_name]
                              }
                          ]
                      )["SecurityGroups"]
                      logger.info(f"Successfully filtered security groups")
                  except Exception as e:
                      logger.error(f"Error filtering security groups: {str(e)}")
                      raise

                  if security_groups:
                      sg_id = security_groups[0]["GroupId"]
                      logger.info(f"Found security group by name: {sg_id}")
                      return sg_id
                  else:
                      logger.error(f"No security group found matching name: {search_name}")
                      raise ValueError(f"Could not find security group for domain {sagemaker_domain_id}")
              except Exception as e:
                  logger.error(f"Error in get_sagemaker_security_group_id: {type(e).__name__}: {str(e)}")
                  raise

          def update_fsx_enis(fsx_id: str, security_group_id: str, action: Literal["add", "remove"] = "add") -> None:
              """
              Update the Elastic Network Interfaces (ENIs) of an FSx filesystem.
              
              Args:
                  fsx_id: The ID of the FSx filesystem
                  security_group_id: The ID of the security group to add/remove
                  action: Either "add" or "remove" (default: "add")
              """
              enis = ec2_client.describe_network_interfaces(
                  Filters=[
                      {
                          "Name": "description",
                          "Values": [f"*{fsx_id}*"]
                      }
                  ]
              )["NetworkInterfaces"]

              logger.info(f"Found {len(enis)} ENIs for FSx filesystem {fsx_id}: {enis}")

              for eni in enis:
                  current_groups = [group['GroupId'] for group in eni['Groups']]
                  
                  if action == "add":
                      if security_group_id not in current_groups:
                          current_groups.append(security_group_id)
                          logger.info(f"Adding security group {security_group_id} to ENI {eni['NetworkInterfaceId']}")
                          
                          ec2_client.modify_network_interface_attribute(
                              NetworkInterfaceId=eni['NetworkInterfaceId'],
                              Groups=current_groups
                          )
                  elif action == "remove":
                      if security_group_id in current_groups:
                          current_groups.remove(security_group_id)
                          logger.info(f"Removing security group {security_group_id} from ENI {eni['NetworkInterfaceId']}")
                          
                          ec2_client.modify_network_interface_attribute(
                              NetworkInterfaceId=eni['NetworkInterfaceId'],
                              Groups=current_groups
                          )

          def update_sagemaker_domain(domain_id: str, security_group_id: str) -> None:
              """
              Update the SageMaker domain to include the security group.

              Args:
                  domain_id: The ID of the SageMaker domain
                  security_group_id: The security group ID to add
              """
              logger.info(f"Adding security group {security_group_id} to SageMaker domain {domain_id}")

              try:
                  domain_response = sagemaker_client.describe_domain(DomainId=domain_id)
                  
                  if "DomainSettings" in domain_response and "SecurityGroupIds" in domain_response["DomainSettings"]:
                      current_security_groups = domain_response["DomainSettings"]["SecurityGroupIds"]
                  else:
                      current_security_groups = []

                  logger.info(f"Current security groups: {current_security_groups}")

                  if security_group_id in current_security_groups:
                      logger.info(f"Security group {security_group_id} is already associated with the domain")
                      return

                  updated_security_groups = current_security_groups + [security_group_id]
                  logger.info(
                      f"Added security group {security_group_id} to SageMaker domain {domain_id}"
                  )

                  response = sagemaker_client.update_domain(
                      DomainId=domain_id,
                      DomainSettingsForUpdate={"SecurityGroupIds": updated_security_groups},
                  )

                  logger.info(f"Successfully updated SageMaker domain security groups. Response: {response}")

              except Exception as e:
                  logger.error(f"Error updating SageMaker domain: {str(e)}")
                  raise

          def manage_fsx_partition(cluster_name: str, partition_name: str, head_node_name: str, additional_users: str) -> None:
              """
              Manage FSx partition using SSM to execute commands on Slurm controller.
              
              Args:
                  cluster_name: Name of the HyperPod Slurm cluster
                  partition_name: Name of the partition to create
              """
              try:
                  # Get controller instance ID
                  controller_info = sagemaker_client.list_cluster_nodes(
                      ClusterName=cluster_name
                  )['ClusterNodeSummaries']

                  controller_index_lambda = lambda out: [i for i, value in enumerate(out) if value['InstanceGroupName'] == head_node_name]
                  controller_index = controller_index_lambda(controller_info)[0]
                  
                  controller_id = controller_info[controller_index]['InstanceId']

                  # Get cluster ID
                  cluster_id = sagemaker_client.describe_cluster(
                      ClusterName=cluster_name
                  )['ClusterArn'].split('/')[-1]

                  # Format SSM target
                  ssm_target = f"sagemaker-cluster:{cluster_id}_{head_node_name}-{controller_id}"

                  # Get list of users (always include ubuntu)
                  users = ['ubuntu'] + [user.strip() for user in additional_users.split(',') if user.strip()]

                  commands = []

                  commands.append(f"sudo mkdir -p /fsx/{partition_name}")

                  # System users/groups that always need access
                  system_entries = [
                      ("u", "200001"),  # SageMaker user
                      ("g", "1001")     # Default group
                  ]

                  # Add commands for system entries
                  for entry_type, entry_id in system_entries:
                      commands.extend([
                          f"sudo setfacl -R -m {entry_type}:{entry_id}:rwx /fsx/{partition_name}",
                          f"sudo setfacl -R -d -m {entry_type}:{entry_id}:rwx /fsx/{partition_name}"
                      ])

                  # Add commands for each user
                  for user in users:
                      commands.extend([
                          f"sudo setfacl -R -m u:{user}:rwx /fsx/{partition_name}",
                          f"sudo setfacl -R -d -m u:{user}:rwx /fsx/{partition_name}",
                          f"sudo setfacl -R -m g:{user}:rwx /fsx/{partition_name}", 
                          f"sudo setfacl -R -d -m g:{user}:rwx /fsx/{partition_name}"
                      ])
                  
                  # Commands to create and set permissions for partition
                  # commands = [
                  #    f"sudo mkdir -p /fsx/{partition_name}",
                  #    f"sudo chown 200001:1001 /fsx/{partition_name}",
                  # ]
                  
                  # commands = [
                  #  f"sudo setfacl -R -m u:200001:rwx /fsx/{partition_name}",
                  #  f"sudo setfacl -R -m u:ubuntu:rwx /fsx/{partition_name}",
                  #  f"sudo setfacl -R -d -m u:200001:rwx /fsx/{partition_name}",
                  #  f"sudo setfacl -R -d -m u:ubuntu:rwx /fsx/{partition_name}"
                  #  f"sudo setfacl -R -d -m g:1001:rwx /fsx/{partition_name}"
                  #  f"sudo setfacl -R -d -m g:ubuntu:rwx /fsx/{partition_name}"
                  # ]

                  # Execute commands via SSM
                  for cmd in commands:
                      response = ssm_client.start_session(
                          Target=ssm_target,
                          DocumentName='AWS-StartInteractiveCommand',
                          Parameters={'command': [cmd]}
                      )
                      logger.info(f"Executed command: {cmd}")
                      time.sleep(1)  # Small delay between commands
                      
              except Exception as e:
                  logger.error(f"Error managing FSx partition: {str(e)}")
                  raise

          def update_domain_filesystem(
              fsx_file_system_id: Union[str, List[str]], 
              sagemaker_domain_id: str, 
              shared: bool) -> None:
              """
              Update the SageMaker domain by attaching an FSx for Lustre volume.
              
              Args:
                  fsx_file_system_id: The ID of the FSx for Lustre volume (string or list)
                  sagemaker_domain_id: The ID of the SageMaker domain to update
                  shared: If True, attach to domain default settings; if False, attach to specific user
              """
              try:
                  if isinstance(fsx_file_system_id, list):
                      logger.info("fsx_file_system_id is a list. Taking the first element")
                      fsx_file_system_id = fsx_file_system_id[0]
                  elif isinstance(fsx_file_system_id, str):
                      logger.info("fsx_file_system_id is a string")
                  else:
                      raise TypeError(f"Type for fsx_file_system_id unsupported: {type(fsx_file_system_id)}")

                  if shared:
                      logger.info(f"Attaching FSx volume {fsx_file_system_id} under /shared")
                      domain_response = sagemaker_client.describe_domain(DomainId=sagemaker_domain_id)

                      already_present = False

                      if "DefaultUserSettings" in domain_response and "CustomFileSystemConfigs" in domain_response["DefaultUserSettings"]:
                          current_file_systems = domain_response["DefaultUserSettings"]["CustomFileSystemConfigs"]

                          for config in current_file_systems:
                              if 'FSxLustreFileSystemConfig' in config:
                                  fsx_config = config['FSxLustreFileSystemConfig']
                                  if fsx_config.get('FileSystemId') == fsx_file_system_id:
                                      already_present = True
                      else:
                          current_file_systems = []

                      if not already_present:
                          logger.info(f"Attaching FSx volume {fsx_file_system_id} to domain {sagemaker_domain_id} under /shared")

                          current_file_systems.append({
                              'FSxLustreFileSystemConfig': {
                                  'FileSystemId': fsx_file_system_id,
                                  'FileSystemPath': '/shared'
                              }
                          })

                          response = sagemaker_client.update_domain(
                              DomainId=sagemaker_domain_id,
                              DefaultUserSettings={
                                  'CustomFileSystemConfigs': current_file_systems
                              },
                          )

                          logger.info(f"Updated Studio Domain {sagemaker_domain_id} and FSx {fsx_file_system_id}")
                      else:
                          logger.info(f"FSx volume {fsx_file_system_id} already attached to domain {sagemaker_domain_id}")
                  else:
                      logger.info(f"Nothing to do on domain {sagemaker_domain_id} with file system {fsx_file_system_id}")

              except Exception as e:
                  logger.error(f"Error updating SageMaker domain: {str(e)}")
                  raise

          def lambda_handler(event: Dict[str, Any], context: Any) -> Optional[Dict[str, Any]]:
              """
              AWS Lambda function handler for attaching FSx volumes to SageMaker domains.
              
              This function handles CloudFormation custom resource requests.
              It attaches an FSx for Lustre filesystem to a SageMaker domain.
              """
              logger.info(f"Received event: {event}")
              
              request_type = event["RequestType"]
              cluster_name = os.environ.get("cluster_name")  
              head_node_name = os.environ.get("head_node_name")
              fsx_file_system_id = os.environ.get("fsx_file_system_id")
              sagemaker_domain_id = os.environ.get("sagemaker_domain_id")
              shared_fsx = os.environ.get("shared_fsx")
              additional_users = os.environ.get("additional_users")

              try:
                  if request_type == "Create" or request_type == "Update":
                      retries = 0
                      sagemaker_security_group_id = None
                      
                      while retries < 2:
                          try:
                              sagemaker_security_group_id = get_sagemaker_security_group_id(sagemaker_domain_id)
                              logger.info(f"Found SageMaker security group {sagemaker_security_group_id}")
                              break
                          except Exception as e:
                              logger.info(f"Waiting for SageMaker security group to be available. Attempt {retries + 1}/2...")
                              if retries == 1:
                                  raise Exception("Failed to find the SageMaker Studio Domain Security Group after 2 attempts") from e
                              time.sleep(10)
                              retries += 1

                      if not sagemaker_security_group_id:
                          raise Exception("SageMaker security group not found")

                      update_fsx_enis(fsx_file_system_id, sagemaker_security_group_id, action="add")
                      update_sagemaker_domain(sagemaker_domain_id, sagemaker_security_group_id)
                      
                      is_shared = shared_fsx in ["True", "true"]
                      
                      if is_shared:
                          manage_fsx_partition(cluster_name, "shared", head_node_name, additional_users)
                          update_domain_filesystem(fsx_file_system_id, sagemaker_domain_id, is_shared)
                      
                      response_data = {
                          "sagemaker_domain_id": sagemaker_domain_id,
                          "sagemaker_security_group_id": sagemaker_security_group_id
                      }
                      
                      send(event, context, SUCCESS, response_data, event["LogicalResourceId"])    
                  elif request_type == "Delete":
                      logger.info("Delete request received. Processing...")
                      
                      retries = 0
                      sagemaker_security_group_id = None
                      
                      while retries < 2:
                          try:
                              sagemaker_security_group_id = get_sagemaker_security_group_id(sagemaker_domain_id)
                              logger.info(f"Found SageMaker security group {sagemaker_security_group_id}")
                              break
                          except Exception as e:
                              logger.info(f"Waiting for SageMaker security group to be available. Attempt {retries + 1}/2...")
                              if retries == 1:
                                  logger.warning("Could not find SageMaker security group, continuing with delete operation")
                                  break
                              time.sleep(10)
                              retries += 1
                      
                      if sagemaker_security_group_id:
                          update_fsx_enis(fsx_file_system_id, sagemaker_security_group_id, action="remove")
                      
                      send(event, context, SUCCESS, {"status": 200}, event["LogicalResourceId"])
                  else:
                      logger.error(f"Unsupported request type")
                      
                      send(event, context, FAILED, {"status": 500}, event["LogicalResourceId"])
                      
                      return {
                          "status": 200,
                          "error": "Unsupported request type"
                      }
              except Exception as error:
                  logger.error(str(error))
                  
                  send(event, context, FAILED, {"status": 500}, event["LogicalResourceId"])
                  
                  return {
                      "status": 500,
                      "error": str(error)
                  }

  SetupFSxToStudioUpdate:
    Type: Custom::SetupFSxToStudioUpdate
    DependsOn:
      - LogsSetupFSxToStudio
      - SageMakerStudioDomain
    Properties:
      ServiceToken: !GetAtt SetupFSxToStudio.Arn

  ## ============================ EventBridge rule ============================

  LogsAttachFSxToStudio:
    Type: AWS::Logs::LogGroup
    #DeletionPolicy: Retain
    Condition: CreatePrivatePartitions
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-attach-fsx-to-profile
      RetentionInDays: 14

  AttachFSxToProfile:
    Type: AWS::Lambda::Function
    Condition: CreatePrivatePartitions
    Properties:
      Description: Lambda function to update FSx Lustre ENIs with SageMaker security group
      FunctionName: !Sub ${AWS::StackName}-attach-fsx-to-profile
      Timeout: 900
      MemorySize: 1024
      EphemeralStorage:
        Size: 2048
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      VpcConfig:
        SecurityGroupIds:
          - !Ref SecurityGroupId
        SubnetIds: !Ref ExistingSubnetIds
      Environment:
        Variables:
          cluster_name: !Ref HyperPodClusterName
          head_node_name: !Ref HeadNodeName
          fsx_file_system_id: !Ref ExistingFSxLustreId
          sagemaker_domain_id: !Ref SageMakerStudioDomain
          shared_fsx: !Ref SharedFSx
          additional_users: !Join [",", !Ref AdditionalUsers]
      Code:
        ZipFile: |
          import os
          import shutil
          import subprocess
          import sys
          import json
          import time
          import logging
          from typing import List, Dict, Any, Optional, Union

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def update_requirements(requirements_list: List[str]) -> None:
              """
              Install Python dependencies in a temporary directory.
              """
              curr_dir = os.getcwd()
              os.chdir('/tmp')

              if os.path.exists("python"):
                  shutil.rmtree("python")
              os.mkdir("python")

              for requirement in requirements_list:
                  logger.info(f"running pip install {requirement}")
                  subprocess.check_call([sys.executable, "-m", "pip", "install", requirement, "-t", "python"])

              os.chdir(curr_dir)

          # Install required packages
          requirements_list = ["boto3==1.37.6"]
          update_requirements(requirements_list)
          sys.path.insert(0, '/tmp/python/')

          import boto3

          sagemaker_client = boto3.client("sagemaker")
          ssm_client = boto3.client('ssm')

          def manage_fsx_partition(cluster_name: str, user_profile_name: str, head_node_name: str, additional_users: str) -> None:
              """
              Create a user-specific partition in FSx using SSM on the Slurm controller node.
              """
              try:
                  # Get controller instance ID
                  controller_info = sagemaker_client.list_cluster_nodes(
                      ClusterName=cluster_name
                  )['ClusterNodeSummaries']

                  controller_index_lambda = lambda out: [i for i, value in enumerate(out) if value['InstanceGroupName'] == head_node_name]
                  controller_index = controller_index_lambda(controller_info)[0]
                  
                  controller_id = controller_info[controller_index]['InstanceId']

                  # Get cluster ID
                  cluster_id = sagemaker_client.describe_cluster(
                      ClusterName=cluster_name
                  )['ClusterArn'].split('/')[-1]

                  # Format SSM target
                  ssm_target = f"sagemaker-cluster:{cluster_id}_{head_node_name}-{controller_id}"

                  # Get list of users (always include ubuntu)
                  users = ['ubuntu'] + [user.strip() for user in additional_users.split(',') if user.strip()]

                  commands = []

                  commands.append(f"sudo mkdir -p /fsx/{user_profile_name}")

                  # System users/groups that always need access
                  system_entries = [
                      ("u", "200001"),  # SageMaker user
                      ("g", "1001")     # Default group
                  ]

                  # Add commands for system entries
                  for entry_type, entry_id in system_entries:
                      commands.extend([
                          f"sudo setfacl -R -m {entry_type}:{entry_id}:rwx /fsx/{user_profile_name}",
                          f"sudo setfacl -R -d -m {entry_type}:{entry_id}:rwx /fsx/{user_profile_name}"
                      ])

                  # Add commands for each user
                  for user in users:
                      commands.extend([
                          f"sudo setfacl -R -m u:{user}:rwx /fsx/{user_profile_name}",
                          f"sudo setfacl -R -d -m u:{user}:rwx /fsx/{user_profile_name}",
                          f"sudo setfacl -R -m g:{user}:rwx /fsx/{user_profile_name}", 
                          f"sudo setfacl -R -d -m g:{user}:rwx /fsx/{user_profile_name}"
                      ])

                  # commands = [
                  #    f"sudo mkdir -p /fsx/{user_profile_name}",
                  #    f"sudo chown 200001:1001 /fsx/{user_profile_name}",
                  # ]
                  
                  # commands = [
                  #  f"sudo setfacl -R -m u:200001:rwx /fsx/{user_profile_name}", 
                  #  f"sudo setfacl -R -m u:ubuntu:rwx /fsx/{user_profile_name}",
                  #  f"sudo setfacl -R -d -m u:200001:rwx /fsx/{user_profile_name}", 
                  #  f"sudo setfacl -R -d -m u:ubuntu:rwx /fsx/{user_profile_name}", 
                  #  f"sudo setfacl -R -d -m g:1001:rwx /fsx/{user_profile_name}",
                  #  f"sudo setfacl -R -d -m g:ubuntu:rwx /fsx/{user_profile_name}"
                  # ]                  
                  
                  # Execute commands via SSM
                  for cmd in commands:
                      response = ssm_client.start_session(
                          Target=ssm_target,
                          DocumentName='AWS-StartInteractiveCommand',
                          Parameters={'command': [cmd]}
                      )
                      logger.info(f"Executed command: {cmd}")
                      time.sleep(1)  # Small delay between commands
                  
                  logger.info(f"Successfully created FSx partition for user {user_profile_name}")

              except Exception as e:
                  logger.error(f"Error managing FSx partition: {str(e)}")
                  raise

          def update_user_profile_filesystem(
              fsx_file_system_id: Union[str, List[str]], 
              sagemaker_domain_id: str, 
              user_profile_name: str, 
              shared: bool
          ) -> None:
              """
              Update the SageMaker User Profile by attaching an FSx for Lustre volume.
              """
              try:
                  if isinstance(fsx_file_system_id, list):
                      logger.info("fsx_file_system_id is a list. Taking the first element")
                      fsx_file_system_id = fsx_file_system_id[0]
                  elif isinstance(fsx_file_system_id, str):
                      logger.info("fsx_file_system_id is a string")
                  else:
                      raise TypeError(f"Type for fsx_file_system_id unsupported: {type(fsx_file_system_id)}")

                  if shared:
                      logger.info(f"Attaching FSx volume {fsx_file_system_id} under /shared")
                      domain_response = sagemaker_client.describe_domain(DomainId=sagemaker_domain_id)

                      already_present = False

                      if "DefaultUserSettings" in domain_response and "CustomFileSystemConfigs" in domain_response["DefaultUserSettings"]:
                          current_file_systems = domain_response["DefaultUserSettings"]["CustomFileSystemConfigs"]

                          for config in current_file_systems:
                              if 'FSxLustreFileSystemConfig' in config:
                                  fsx_config = config['FSxLustreFileSystemConfig']
                                  if fsx_config.get('FileSystemId') == fsx_file_system_id:
                                      already_present = True
                      else:
                          current_file_systems = []

                      if not already_present:
                          logger.info(f"Attaching FSx volume {fsx_file_system_id} to domain {sagemaker_domain_id} under /shared")

                          current_file_systems.append({
                              'FSxLustreFileSystemConfig': {
                                  'FileSystemId': fsx_file_system_id,
                                  'FileSystemPath': '/shared'
                              }
                          })

                          response = sagemaker_client.update_domain(
                              DomainId=sagemaker_domain_id,
                              DefaultUserSettings={
                                  'CustomFileSystemConfigs': current_file_systems
                              }
                          )

                          logger.info(f"Updated Studio Domain {sagemaker_domain_id} and FSx {fsx_file_system_id}")
                      else:
                          logger.info(f"FSx volume {fsx_file_system_id} already attached to domain {sagemaker_domain_id}")
                  else:
                      logger.info(f"Attaching FSx volume {fsx_file_system_id} under /fsx/{user_profile_name}")

                      response = sagemaker_client.update_user_profile(
                          DomainId=sagemaker_domain_id,
                          UserProfileName=user_profile_name,
                          UserSettings={
                              'CustomFileSystemConfigs': [
                                  {
                                      'FSxLustreFileSystemConfig': {
                                          'FileSystemId': fsx_file_system_id,
                                          'FileSystemPath': f'/{user_profile_name}'
                                      }
                                  }
                              ]
                          }
                      )

                      logger.info(f"Updated Studio User {user_profile_name} for Domain {sagemaker_domain_id} and FSx {fsx_file_system_id}")

              except Exception as e:
                  logger.error(f"Error updating SageMaker domain or user profile: {str(e)}")
                  raise

          def lambda_handler(event: Dict[str, Any], context: Any) -> Optional[Dict[str, Any]]:
              """
              AWS Lambda function handler for attaching FSx volumes to SageMaker user profiles.
              """
              logger.info(f"Received event: {event}")
              shared_fsx = os.environ.get("shared_fsx")
              head_node_name = os.environ.get("head_node_name")
              additional_users = os.environ.get("additional_users")
              
              is_shared = shared_fsx in ["True", "true"]
              
              if not is_shared:
                  if "detail" in event and "requestParameters" in event["detail"] and "userProfileName" in event["detail"]["requestParameters"]:
                      user_profile_name = event["detail"]["requestParameters"]["userProfileName"]
                      logger.info(f"User profile is {user_profile_name}")
                  else:
                      raise Exception("Could not find user profile name in event")

                  cluster_name = os.environ.get("cluster_name")
                  fsx_file_system_id = os.environ.get("fsx_file_system_id")
                  sagemaker_domain_id = os.environ.get("sagemaker_domain_id")

                  try:
                      # Create user-specific partition in FSx
                      manage_fsx_partition(cluster_name, user_profile_name, head_node_name, additional_users)
                      update_user_profile_filesystem(fsx_file_system_id, sagemaker_domain_id, user_profile_name, False)
                          
                      response_data = {
                          "user_profile_name": user_profile_name,
                          "partition": f"/fsx/{user_profile_name}"
                      }
                      
                      return response_data
                  except Exception as error:
                      logger.error(str(error))

                      return {
                          "status": 500,
                          "error": str(error)
                      }
              else:
                  logger.info("Shared FSx")
                  
                  return {
                      "status": 200,
                      "message": "Shared FSx, no action needed"
                  }

  EventBridgeRuleCreateUserProfile:
    Type: AWS::Events::Rule
    Condition: CreatePrivatePartitions
    DependsOn:
      - SageMakerStudioDomain
    Properties:
      EventPattern:
        detail-type:
          - AWS API Call via CloudTrail
        source:
          - aws.sagemaker
        detail:
          eventSource:
            - sagemaker.amazonaws.com
          eventName:
            - CreateUserProfile
      Description: EventBridge Rule triggered when a new Studio User Profile is
        created. It will invoke a Lambda function that will create an FSx
        directory for such user.
      State: ENABLED
      Targets:
        - Arn: !GetAtt AttachFSxToProfile.Arn
          Id: TargetLambda
      Name: !Sub ${AWS::StackName}-eb-rule-CreateUserProfile

  PermissionForEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Condition: CreatePrivatePartitions
    Properties:
      FunctionName: !GetAtt AttachFSxToProfile.Arn
      Action: lambda:InvokeFunction
      SourceArn: !GetAtt EventBridgeRuleCreateUserProfile.Arn
      Principal: events.amazonaws.com

Outputs:
  StudioDomainId:
    Value: !Ref SageMakerStudioDomain
    Description: SageMaker Studio Domain ID
  SecurityGroupForNFS:
    Value: !Sub security-group-for-inbound-nfs-${SageMakerStudioDomain}
    Description: Security Group ID that needs to be added to FSx Lustre ENIs
